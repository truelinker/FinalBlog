<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>A career That&#39;s Real on Blogophonic</title>
    <link>https://truelinker.github.io/MyungBlog/career/</link>
    <description>Recent content in A career That&#39;s Real on Blogophonic</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 20 Feb 2019 09:31:27 -0600</lastBuildDate><atom:link href="https://truelinker.github.io/MyungBlog/career/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Flash FileSystem</title>
      <link>https://truelinker.github.io/MyungBlog/career/filesystem/</link>
      <pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/filesystem/</guid>
      <description>Implmented a file system on a QSPI NOR Flash. Azura RTOS(aka, ThreadX) provides FileX/LevelX to help develop FAT16/32 file systems on flash memory. I used this API to implement a file system for firmware running on Azura RTOS(aka, ThreadX) over QSPI NOR flash memory.
Background knowledges  FileX : FAT-compatible file system libraries. LevelX : Handle NAND or NOR flash memories managment for wear-leveling to increase the memory lifetime and support multiplie instances of NAND and/or NOR pairs.</description>
    </item>
    
    <item>
      <title>Flash Writer Implementation for Embedded Systems</title>
      <link>https://truelinker.github.io/MyungBlog/career/flashwriter/</link>
      <pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/flashwriter/</guid>
      <description>Project Overview Developed a sophisticated Flash Writer application for initializing flash memory in new embedded systems. This critical tool enables the programming of secondary boot loaders (SBL) and establishes the foundation for multi-core boot sequences.
Technical Architecture Boot Sequence Architecture The boot sequence follows a carefully orchestrated process, starting from ROM and progressing through multiple stages:
Figure 1: Complete boot sequence flow showing ROM, Flash Writer, and SBL stages
Flash Writer Operation Flow Initial Download Phase Figure 2: Flash Writer download and initialization sequence</description>
    </item>
    
    <item>
      <title>Optimizing DPD Algorithm with ARM NEON SIMD</title>
      <link>https://truelinker.github.io/MyungBlog/career/neonsimd/</link>
      <pubDate>Mon, 29 Apr 2024 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/neonsimd/</guid>
      <description>Project Overview This project focused on significantly improving the performance of Digital Predistortion (DPD) algorithm implementation through ARM NEON SIMD optimization. The optimization resulted in substantial performance gains by leveraging parallel processing capabilities of ARM architecture.
Technical Background Digital Predistortion (DPD) Digital Predistortion is a crucial technique in modern wireless communication systems that compensates for power amplifier (PA) nonlinearities. The process works by:
 Pre-analyzing the PA&amp;rsquo;s nonlinear characteristics Applying inverse distortion to the input signal Achieving linear output after PA processing  Figure 1: Digital Predistortion working principle showing signal transformation stages</description>
    </item>
    
    <item>
      <title>Layer 2 switch development</title>
      <link>https://truelinker.github.io/MyungBlog/career/ethernetswitch/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/ethernetswitch/</guid>
      <description>When I was working at Dasan Networks ( https://en.wikipedia.org/wiki/DASAN_Networks ), I developed a Layer 2 switch device based on Dasan Networks&#39; custom Linux using Broadcom and Marvell&amp;rsquo;s Layer 2 switch SoCs. In addition, I have developed DHCP and ARP and other functions.  The following figure shows the Linux network stack of 24 port ethernet switch. Layer 2 switch SoCs provides basic functions such as RX/TX Ring Buffer and MAC address learning table as shown in the figure below.</description>
    </item>
    
    <item>
      <title>PCIe AHCI Device Driver Development</title>
      <link>https://truelinker.github.io/MyungBlog/career/pciedevicedriver/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/pciedevicedriver/</guid>
      <description>Project Overview Led the development of a PCIe AHCI device driver for a Solid State Hybrid Drive (SSHD) system. This innovative storage solution combines HDD capacity with SSD performance by utilizing a PCIe-connected SSD cache for frequently accessed data.
Technical Architecture System Overview The SSHD architecture integrates traditional HDD storage with a PCIe-connected SSD cache:
Figure 1: High-level architecture of the Hybrid Storage System
PCIe Port Initialization Flow The PCIe controller initialization follows a precise sequence to ensure reliable operation:</description>
    </item>
    
    <item>
      <title>Secure Drive</title>
      <link>https://truelinker.github.io/MyungBlog/career/secure-drive/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/secure-drive/</guid>
      <description>Now I&amp;rsquo;m working at Western Digital as a firmware developer on a team that provides a common security engine for SSDs and HDDs. I am in charge of developing Security APIs so that the security engine provided by the team can be used according to the HDD characteristics.  TCG protocols (TCG enterprise, opal, pyrite, etc). Sanitize ATA Security   1. [TCG] (https://nvmexpress.org/wp-content/uploads/TCGandNVMe_Joint_White_Paper-TCG_Storage_Opal_and_NVMe_FINAL.pdf) provides that data stored on HDDs or SSDs is self-encrypted under policy-based access control.</description>
    </item>
    
    <item>
      <title>Serial communication</title>
      <link>https://truelinker.github.io/MyungBlog/career/sio/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/sio/</guid>
      <description>I developed a serial communication protocol. As for the background, as the tester that uses only a single serial bus was newly introduced, I had to change the firmware to use it with the tester that uses the existing dual serial bus, and I was in charge of developing the fimrware. The purpose of this project is to change the firmware to work with testers with different serial communication methods on the same firmware.</description>
    </item>
    
    <item>
      <title>SMR</title>
      <link>https://truelinker.github.io/MyungBlog/career/smr/</link>
      <pubDate>Tue, 30 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://truelinker.github.io/MyungBlog/career/smr/</guid>
      <description>Participated in the drive managed SMR HDD development. Because the size of Read Header in HDD is smaller than Write Header, it is possible to write more densely when writing. This is the basic concept of SMR (Shingled Magnetic Recording). There are two main types of SMR HDDs: Host Managed SMR and Drive Managed SMR. The reason for dividing into two is that for SMR drives capable of only sequential write/read, the location of LBA and actual physical location is different each time it is written, so an indirection mapping table is needed for this.</description>
    </item>
    
  </channel>
</rss>
